#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
int main()
{
	//移位操作符
	//<<左移
	//>>右移
	int a = 1;
	//整形占4个字节 -	32个比特位
	//00000000000000000000000000000001		1
	//<<左移
	//00000000000000000000000000000100		4
	int b = a << 2;
	printf("%d\n", b);
	printf("%d\n", a);//a本身不变

	//位操作符		二进制位
	//&		按位与		并且	0为假	1为真
	//||	按位或		或者
	//^		按位异或	相同为0	不同为1
	int c = 3;
	int d = 5;
	int e = c & d;
	//a	011
	//d	101
	//e	001

	//单目操作符		双目操作符		三目操作符
	
	//a + b;//有两个操作数，所以是双目操作符
	//单目操作符
	//!		逻辑反操作符
	//sizeof	计算的是变量/类型所占的空间大小，单位是字节
	//~		按位取反	二进制
	printf("%d\n", sizeof a);//计算变量大小时，两边的括号可以省略（）
	printf("%d\n", sizeof (int));//计算类型大小时，两边的括号不可以省略

	int array[10] = { 0 };//10给整形元素的数组
	//10*sizeof(int) = 40
	printf("%d\n", sizeof(array));
	int sz = 0;
	sz = sizeof(array) / sizeof(array[0]);//计算元素个数=总大小/元素大小
	printf("%d\n", sz);
	int a1 = 0;
	int b1 = ~a1;
	printf("%d\n", b1);//-1
	//原码，反码，补码
	//负数在内存中存储的时候，存储的是二进制的补码
	//使用的，打印的是这个数的原码
	//符号位是左边第一位
	//原码 → 符号位不变，其他位按位取反得到反码
	//反码 → 反码加一得到补码
	//11111111111111111	补码
	//11111111111111110	反码
	//10000000000000001	原码

	//后置++	先使用，在加
	//++前置	先加，在使用
	//后置--和--前置同理
	int a2 = 10;
	int b2 = a2++;
	printf("a = %d b = %d\n", a2, b2);//11	10
	int a3 = 10;
	int b3 = ++a3;
	printf("a = %d b = %d\n", a3, b3);//11 11
	//(类型)	强制类型转换
	int a4 = (int)3.14;
	printf("%d\n", a4);//3
	return 0;
}